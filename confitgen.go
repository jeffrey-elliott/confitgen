// configen.go
package confitgen

import (
	"encoding/json"
	"errors"
	"fmt"
	"go/format"
	"io"
	"log"
	"strings"
)

const SUFFIX_SCHEMA = "ConfitSchema"

type FormattingStringBuilder struct {
	buf *strings.Builder
}

func (w *FormattingStringBuilder) ff(format string, args ...any) {
	fmt.Fprintf(w.buf, format, args...)
}
func (w *FormattingStringBuilder) ln(args ...any) {
	fmt.Fprintln(w.buf, args...)
}
func (w *FormattingStringBuilder) String() string {
	return w.buf.String()
}
func NewFormattingStringBuilder() *FormattingStringBuilder {
	buf := new(strings.Builder)
	return &FormattingStringBuilder{buf}
}

// Unwraps a validated top-level JSON object with exactly one root.
// Returns the root key and the contents of the root node as map[string]any.
func loadRoot(data []byte, suffix string) (string, map[string]any, error) {
	var root map[string]json.RawMessage
	if err := json.Unmarshal(data, &root); err != nil {
		return "", nil, fmt.Errorf("invalid JSON: %w", err)
	}

	if len(root) != 1 {
		return "", nil, fmt.Errorf("want exactly one root key, got %d", len(root))
	}

	for k, v := range root {
		if !strings.HasSuffix(k, suffix) {
			return "", nil, fmt.Errorf("root key %q must end with %q", k, suffix)
		}

		var inner map[string]any
		if err := json.Unmarshal(v, &inner); err != nil {
			return "", nil, fmt.Errorf("invalid object under root %q: %w", k, err)
		}

		return strings.TrimSuffix(k, suffix), inner, nil
	}

	return "", nil, errors.New("unreachable: no key found")
}

func Generate(w io.Writer, schemaData []byte) error {
	typeName, nodes, err := loadRoot(schemaData, SUFFIX_SCHEMA)
	if err != nil {
		log.Fatalf("failed to load root: %v", err)
	}

	packageName := strings.ToLower(typeName)
	b := NewFormattingStringBuilder()

	AppendImports(packageName, b)
	AppendTypes(typeName, nodes, b)
	AppendFunctions(typeName, b)

	formatted, err := format.Source([]byte(b.String()))
	if err != nil {
		return fmt.Errorf("formatting failed: %w", err)
	}

	_, err = w.Write(formatted)
	return err
}

func AppendTypes(name string, nodes map[string]any, b *FormattingStringBuilder) {
	type item struct {
		name string
		node map[string]any
	}
	stack := []item{{name, nodes}}

	for len(stack) > 0 {
		n := stack[len(stack)-1]
		stack = stack[:len(stack)-1]

		b.ff("type %s struct {\n", n.name)

		for k, v := range n.node {
			switch vt := v.(type) {
			case string:
				b.ff("%s %s `json:\"%s\"`\n", k, vt, k)
			case map[string]any:
				b.ff("%s %s `json:\"%s\"`\n", k, k, k)
				stack = append(stack, item{k, vt})
			default:
				panic(fmt.Sprintf("unsupported schema value for key %q", k))
			}
		}

		b.ln("}")
		b.ln()
	}
}

func AppendImports(packageName string, b *FormattingStringBuilder) {
	b.ln("// Code generated by confitgen. DO NOT EDIT.")
	b.ff("// /internal/confit/%s.go\n", packageName)
	b.ff("package %s\n", packageName)
	b.ln()
	b.ln("import (")
	b.ln(`"encoding/json"`)
	b.ln(`"os"`)
	b.ln(")")
	b.ln()
}

func AppendFunctions(typeName string, b *FormattingStringBuilder) {
	b.ff("func New() %[1]s { return %[1]s{} }\n", typeName)
	b.ff("func Load(path string) (%s, error) {\n", typeName)
	b.ln("cf := New()")
	b.ln("data, err := os.ReadFile(path)")
	b.ln("if err != nil { return cf, err }")
	b.ln("if err := json.Unmarshal(data, &cf); err != nil { return cf, err }")
	b.ln("return cf, nil")
	b.ln("}")
}
